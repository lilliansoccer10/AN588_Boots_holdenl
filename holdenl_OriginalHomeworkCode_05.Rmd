---
title: "Boots for Days!"
author: "Lillian Holden"
date: "2023-11-13"
output: rmdformats::readthedown
---

### Use library() to access the following packages: 
```{r message=FALSE, warning=FALSE}
library(curl)
library(ggplot2)
library(tidyverse)
library(manipulate)
```

## Part One 

### Using the “KamilarAndCooperData.csv” dataset, run a linear regression looking at log(HomeRange_km2) in relation to log(Body_mass_female_mean) and report your β coeffiecients (slope and intercept).


### Import the Data Set

```{r}
f <- curl("https://raw.githubusercontent.com/fuzzyatelin/fuzzyatelin.github.io/master/AN588_Fall23/KamilarAndCooperData.csv")
d <- read.csv(f, header = TRUE, sep = ",", stringsAsFactors = FALSE) #Assign D as the vector for the data set
head(d)
```

### Determine the Intercept(B0) and Slope (B1) by Calling The Information

```{r}
mI <-  lm(log(HomeRange_km2) ~ log(Body_mass_female_mean), data = d)
summary(mI)
```
The Slope of This Linear Regression is 1.03643, and the intercept is -9.44123. 

### Plot and Add A Fitted Line Using ggplot2 

```{r warning=FALSE}
h <- ggplot(data = d, aes(x = log(HomeRange_km2), y = log(Body_mass_female_mean)))
h <- h + geom_point()
h <- h + geom_smooth(method = "lm", formula = y ~ x)
h + annotate("text", x = 2, y = 6.5, label = "y=1.03643 x - 9.44123")
```

<br>

## Part Two 

### Then, use bootstrapping to sample from your data 1000 times with replacement, each time fitting the same model and calculating the same coefficients. This generates a sampling distribution for each β coefficient.

```{r}
sample_coef_intercept <- NULL #intercept
sample_coef_x1 <- NULL #slope

for (i in 1:1000) {
  #Creating a resampled dataset from the sample data
  sample_d = d[sample(1:nrow(d), nrow(d), replace = TRUE), ]
  
  #Running the regression on these data
  model_bootstrap <- lm(log(HomeRange_km2) ~ log(Body_mass_female_mean), data = sample_d)
  
  #Saving the coefficients
  sample_coef_intercept <-
    c(sample_coef_intercept, model_bootstrap$coefficients[1])
  
  sample_coef_x1 <-
    c(sample_coef_x1, model_bootstrap$coefficients[2])
}
```

# Taking the Mean and Standard Deviation of the 1000 Samples of Each Coefficient
```{r}
a<- mean(sample_coef_intercept)
b<- mean(sample_coef_x1)
a
b
c <- sd(sample_coef_intercept)
c
d<- sd(sample_coef_x1)
d
```
#Estimating the Standard Errors Based on the Standard Deviation of Each Coefficient
```{r}
seI <- c/sqrt(length(sample_coef_intercept))
seII <- d/sqrt(length(sample_coef_x1))
seI
seII
```


### Also do the following:
- Estimate the standard error for each of your β coefficients as the standard deviation of the sampling distribution from your bootstrap and determine the 95% CI for each of your β coefficients based on the appropriate quantiles from your sampling distribution.

- How does the former compare to the SE estimated from your entire dataset using the formula for standard error implemented in lm()?

- How does the latter compare to the 95% CI estimated from your entire dataset?
